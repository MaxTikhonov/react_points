{
 "unit1": [
  "React - структура проекта",
  "React-приложение создается командой npx create-react-app my-app", "React-приложение можно писать в функциональном стиле, а можно использовать классы. Первый метод предпочтительнее, потому что лучше поддается дебагингу.", "return компонента должен возращать только один главный тег, внутри которого может быть сколько угодно тегов. Но главный тег может быть один", "классы css объявляются словом className в теге html, поскольку слово class в js зарезервировано", "создав компонент его нужно экспортировать, использовав export default component", "для того, чтобы использовать Router или Link их нужно импортировать из 'react-router-dom' ", "точно так же происходит импорт всего остального. устанавливаем необходимый пакет и импортируем его туда, куда нам нужно"
 ],
 "unit2": [
  "Компоненты, создание компонентов и вложенных компонентов",
  "Чтобы создать SPA-приложение используется тег Link","синтаксис Link - <Link to='/main/cat'>{text}</Link>", "в компоненты можно передавать пропсы props. в родителе это будет выглядеть так const data = {nav: ['1', '2']} <Header data={data}. В ребенке получаем пропс function Header(props) {} и уже делаем с ним что хотим. Например создаем на его основе каркас компонента распечатав через map. Например: const data = props.data.nav; let list = data.map(item => <li key={item}>{item}</li>)"
 ],
 "unit3" : [
  "Routing, создание SPA и MPA",
  "Чтобы создать роутинг подключаются сущности из пакета react-router-dom следующим образом import { BrowserRouter as Router, Routes, Route } from 'react-router-dom'; Где Router является как бы оболочкой для всего того, что будет роутиться, а Router - это как Switch в более ранних версиях, в Route указывается путь который будет считываться из адресной строки браузера и если она поменяется, будет происходить сопоставление и отрисовываться компонент, прописанный для отрисовки. Выглядит это так <Route path='/cat' element={<Category data={categoryData} />} />", "точно также в Route можно передавать и пропсы компоненту, ничего не меняется в этом плане", "чтобы создать страницу 404 используется такой синтаксис <Route path='*' element={<Error />} />"
 ],
 "unit4" : [
  "События и функции. Получаем значение из input", "Для того чтобы повешать обработчик используется такой синтаксис в jsx - <button onInput={showInput}> Push </button> похож на обычный обработчик в html", "но если надо передать в функцию аргументы, используем стрелочную таким образом <button onInput={()=> showInput(arg)}> Push </button>", "чтобы получить значение из input вешаем событие onInput и передаем функцию, чтобы в ней вывести вбиваемое значение, просто используем event.target.value, как обычно, ничего нового", "но помимо этого существуют и другие способы.", "в реакте есть управляемые и неуправляемые компоненты. есть сущность ref, которая позволяет обратиться к элементу по какому-то идентификатору. чтобы создать реф, надо имортировать React from 'react', создать переменную, использовав метод реакта createRef(). Таким образом -  let textInput = React.createRef(); и присвоить идентификатор html-тегу ref={textInput}. Это позволяет в компоненте иметь всегда значение какого-то конкретного инпута, чтобы другие части компонента могли работать 'пляша' от этого значения", "но ref не позволит отрендерить части компонента в зависимости от состояния. Поэтому на помощь приходит хук useState.", "подключаем хук import { useState } from 'react'; создаем переменную и функцию отвечающую за обновление этой переменной таким образом - let [output, setOutput] = useState('Hello'). Теперь если создать функцию, отвечающую за обновление ссылки к другому изображению по условию и передать ее в обработчик, то при соблюдении условий можно вызвать функцию setOutput, передать ей новое значение и части компонента отрендерятся и покажут новую картинку по новому пути" 
 ],
 "unit5": [
  "Изучаем State в React", "если мы используем хук useState и нам надо реализовать счетчик, то правильно будет пользоваться сущностью prev в созданной нам функции, чтобы верно работать с переменной помещенной в useState. Выглядит это так. const [count, setCount] = useState(0) frunction name() {setCount((prev) => prev + 1)} при такой записи отображение и обновление будет корректным", "если мы хотим создавать рандомный цвет и присваивать его блоку, то надо использовать useState и отдельно создать объект в котором будет лежать свойство background: st1, выглядит это так const [st1, setSt1] = useState(''); const style1 = {background: st1} потом создаем рандомный цвет и присваимем его в st1 function name() {setSt1(randomColor)} затем в верстке используем следующую конструкци <div style={style1}></div>", "я думаю что это не единственный способ как на лету менять стили, но пока знаю только его"
 ],
 "unit6": [ 
  "Жизненный цикл компонентов в React", "при изменении значений в state компонента, происходит вызов функции render() компонента, при этом не происходит вызов constructor компонента, компонент просто перерисовывается", "можно передать props в классовый компонент, для этого в конструктор передается пропс constructor(props), а передача происходит как обычно <Test arg={77}/> . При этом можно уже на этапе конструктора переменным в state назначить значение из props выглядит это так constructor(props) {super(); this.state = {s1: props.arg}} и при создании компонента данные из пропса попадут в переменную s1 и отобразятся на странице", "но при таком способе передачи и использования пропсов мы можем быть ограничены, если пропсы будут динамическими, то есть будут постоянно обновляться где-то вне компонента, в который они передаются. и если их назначать на этапе конструктора в state, то пропсы залетят один раз и больше мы не увидим изменений, которые возможно могут произойти вне нашего компонента, поэтому для таких целей есть специальный метод, о нем узнаю позже", "метод static getDerivedStateFromProps(props, state) {return ({ s1: props.arg })} запускается при каждой перерисовке, служит для того, чтобы посмотреть что находится в пропсах, проверить изменились ли они и обновить стейт компонента", "метод componentDidMount() запускается тогда, когда компонент был выведен и закончил отрисовку, данный метод не запускается второй раз, при действиях приводящих к изменению state, а значит приводящих к перерендеру компонента" 
 ]
}
